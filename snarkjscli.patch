--- cli.cjs	2022-04-26 13:02:28.000000000 -0300
+++ climod.cjs	2022-04-26 13:05:22.000000000 -0300
@@ -5382,6 +5382,110 @@
 
     return ejs__default["default"].render(template ,  verificationKey);
 }
+async function exportCairoVerifier(zKeyName, templates, logger) {
+
+    const verificationKey = await zkeyExportSplitVerificationKey(zKeyName);
+
+    let template = templates[verificationKey.protocol];
+
+    return ejs__default["default"].render(template ,  verificationKey);
+}
+async function zkeyExportSplitVerificationKey(zkeyName, /* logger */ ) {
+
+    const {fd, sections} = await binFileUtils__namespace.readBinFile(zkeyName, "zkey", 2);
+    const zkey = await readHeader$1(fd, sections);
+
+    let res;
+    if (zkey.protocol == "groth16") {
+        res = await groth16VkSplit(zkey, fd, sections);
+    } else if (zkey.protocol == "plonk") {
+        res = await plonkVk(zkey);
+    } else {
+        throw new Error("zkey file is not groth16");
+    }
+
+    await fd.close();
+
+    return res;
+}
+async function groth16VkSplit(zkey, fd, sections) {
+    const curve = await getCurveFromQ(zkey.q);
+    const sG1 = curve.G1.F.n8*2;
+
+    const alphaBeta = await curve.pairing( zkey.vk_alpha_1 , zkey.vk_beta_2 );
+
+    let vKey = {
+        protocol: zkey.protocol,
+        curve: curve.name,
+        nPublic: zkey.nPublic,
+
+        vk_alpha_1: curve.G1.toObject(zkey.vk_alpha_1),
+        vk_beta_2: curve.G2.toObject(zkey.vk_beta_2),
+        vk_gamma_2:  curve.G2.toObject(zkey.vk_gamma_2),
+        vk_delta_2:  curve.G2.toObject(zkey.vk_delta_2),
+
+        vk_alphabeta_12: curve.Gt.toObject(alphaBeta)
+    };
+
+    // Read IC Section
+    ///////////
+    await binFileUtils__namespace.startReadUniqueSection(fd, sections, 3);
+    vKey.IC = [];
+    for (let i=0; i<= zkey.nPublic; i++) {
+        const buff = await fd.read(sG1);
+        const P = curve.G1.toObject(buff);
+        vKey.IC.push(P);
+    }
+    await binFileUtils__namespace.endReadSection(fd);
+
+    vKey = stringifyBigInts$3(vKey);
+    
+    let VK = {
+        protocol: vKey.protocol,
+        curve: vKey.curve,
+        nPublic: vKey.nPublic,
+
+        vk_alpha_1: split_array(vKey.vk_alpha_1),
+        vk_beta_2: split_matrix(vKey.vk_beta_2),
+        vk_gamma_2: split_matrix(vKey.vk_gamma_2),
+        vk_delta_2: split_matrix(vKey.vk_delta_2),
+
+        vk_alphabeta_12: vKey.vk_alphabeta_12,
+
+        IC : split_matrix(vKey.IC)
+    };
+
+    vKey = stringifyBigInts$3(vKey);
+    return VK;
+}
+
+function split_matrix(matrix) {
+
+    let split_matrix = []
+
+    for(let i=0; i< matrix.length; i++) {
+
+        split_matrix[i] = split_array(matrix[i])
+    }
+    return split_matrix
+}
+function split_array(array) {
+
+    let split_array = [];
+    
+    let j = 0;
+    for (let i = 0; i < array.length; i++) {
+        let split = split_bigint(array[i]);
+        split_array[j] = split[0];
+        split_array[j + 1] = split[1];
+        split_array[j + 2] = split[2];
+
+        j = j + 3;
+    }
+
+    return split_array
+}
+
 
 /*
     Copyright 2018 0KIMS association.
@@ -6025,6 +6129,79 @@
     return S;
 }
 
+async function groth16ExportCairoCallData(proof, pub) {
+    let split_pub = split_array(pub)
+    let split_proof = { }
+    split_proof.pi_a = split_array(proof.pi_a)
+    split_proof.pi_b = split_matrix(proof.pi_b)
+    split_proof.pi_c = split_array(proof.pi_c)
+
+    let S = ""
+    S = add_array_numbers_to_string(split_proof.pi_a, 6, S)
+    S = twist_add_matrix_to_string(split_proof.pi_b, 6, S)
+    S = add_array_numbers_to_string(split_proof.pi_c, 6, S)
+    S = add_array_numbers_to_string(split_pub, split_pub.length, S)
+
+    return S;
+}
+
+function twist_array(array){
+    let new_array = []
+    new_array[0] = array[3]
+    new_array[1] = array[4]
+    new_array[2] = array[5]
+    new_array[3] = array[0]
+    new_array[4] = array[1]
+    new_array[5] = array[2]
+
+    return new_array
+}
+
+function twist_add_matrix_to_string(matrix, array_length, string){
+    matrix[0] = twist_array(matrix[0])
+    matrix[1] = twist_array(matrix[1])
+
+    string = add_array_numbers_to_string(matrix[0], 6, string)
+    string = add_array_numbers_to_string(matrix[1], 6, string)
+
+    return string
+}
+
+function add_array_numbers_to_string(array, length, string){
+
+    string = string + " " + length
+
+    for(let i=0; i<length; i++) {
+
+            string = string + " "
+            string = string + array[i]
+    }
+
+    return string
+
+}
+
+function split_bigint(bigint) {
+
+    let input = BigInt(bigint);
+
+    // Base is 2^86
+    const base = BigInt(77371252455336267181195264);
+    let rem = 0
+    let div = 0
+    let parts = [];
+    for (let i = 0; i < 3; i++) {
+        rem = input % base;
+        div = input / base;
+
+        parts.push(rem);
+
+        input = div;
+}
+
+    return parts
+}
+
 /*
     Copyright 2021 0kims association.
 
@@ -8101,12 +8278,24 @@
         action: zkeyExportSolidityVerifier
     },
     {
+        cmd: "zkey export cairoverifier [circuit_final.zkey] [verifier.sol]",
+        description: "Creates a verifier in cairo",
+        alias: ["zkecv", "generateverifier -vk|verificationkey -v|verifier"],
+        action: zkeyExportCairoVerifier
+    },
+    {
         cmd: "zkey export soliditycalldata [public.json] [proof.json]",
         description: "Generates call parameters ready to be called.",
         alias: ["zkesc", "generatecall -pub|public -p|proof"],
         action: zkeyExportSolidityCalldata
     },
     {
+        cmd: "zkey export cairocalldata [public.json] [proof.json]",
+        description: "Generates call parameters ready to be called.",
+        alias: ["zkecc", "generatecairocall -pub|public -p|proof"],
+        action: zkeyExportCairoCalldata
+    },
+    {
         cmd: "groth16 setup [circuit.r1cs] [powersoftau.ptau] [circuit_0000.zkey]",
         description: "Creates an initial groth16 pkey file with zero contributions",
         alias: ["g16s", "zkn", "zkey new"],
@@ -8451,6 +8640,39 @@
 
     return 0;
 }
+// cairo genverifier [circuit_final.zkey] [verifier.cairo]
+async function zkeyExportCairoVerifier(params, options) {
+    let zkeyName;
+    let verifierName;
+
+    if (params.length < 1) {
+        zkeyName = "circuit_final.zkey";
+    } else {
+        zkeyName = params[0];
+    }
+
+    if (params.length < 2) {
+        verifierName = "verifier.cairo";
+    } else {
+        verifierName = params[1];
+    }
+
+    if (options.verbose) Logger__default["default"].setLogLevel("DEBUG");
+
+    const templates = {};
+
+    if (await fileExists(path__default["default"].join(__dirname$1, "templates"))) {
+        templates.groth16 = await fs__default["default"].promises.readFile(path__default["default"].join(__dirname$1, "templates", "verifier_groth16.cairo.ejs"), "utf8");   
+    } else {
+        templates.groth16 = await fs__default["default"].promises.readFile(path__default["default"].join(__dirname$1, "..", "templates", "verifier_groth16.cairo.ejs"), "utf8");  
+    }
+    
+    const verifierCode = await exportCairoVerifier(zkeyName, templates);
+
+    fs__default["default"].writeFileSync(verifierName, verifierCode, "utf-8");
+
+    return 0;
+}
 
 
 // solidity gencall <public.json> <proof.json>
@@ -8488,6 +8710,39 @@
     return 0;
 }
 
+// cairo gencall <public.json> <proof.json>
+async function zkeyExportCairoCalldata(params, options) {
+    let publicName;
+    let proofName;
+
+    if (params.length < 1) {
+        publicName = "public.json";
+    } else {
+        publicName = params[0];
+    }
+
+    if (params.length < 2) {
+        proofName = "proof.json";
+    } else {
+        proofName = params[1];
+    }
+
+    if (options.verbose) Logger__default["default"].setLogLevel("DEBUG");
+
+    const pub = unstringifyBigInts(JSON.parse(fs__default["default"].readFileSync(publicName, "utf8")));
+    const proof = unstringifyBigInts(JSON.parse(fs__default["default"].readFileSync(proofName, "utf8")));
+
+    let res;
+    if (proof.protocol == "groth16") {
+        res = await groth16ExportCairoCallData(proof, pub);
+    } else {
+        throw new Error("Invalid Protocol");
+    }
+    console.log(res);
+
+    return 0;
+}
+
 // powersoftau new <curve> <power> [powersoftau_0000.ptau]",
 async function powersOfTauNew(params, options) {
     let curveName;
